#!/usr/bin/env tsx
import { execSync } from "node:child_process";
import { existsSync, mkdirSync, writeFileSync, readFileSync } from "node:fs";
import { join } from "node:path";
import { PAGE_CONFIGS, getAffectedPages, type PageConfig } from "./page-config";

const WORKER_URL =
  process.env.SCREENSHOT_WORKER_URL ??
  "https://kumo-screenshot-worker.design-engineering.workers.dev";
const SCREENSHOTS_DIR = "ci/visual-regression/screenshots";
const API_KEY = process.env.SCREENSHOT_API_KEY ?? "";

interface ScreenshotResult {
  url: string;
  image: string;
  error?: string;
}

interface WorkerResponse {
  results: ScreenshotResult[];
}

interface ComparisonResult {
  page: string;
  state: string;
  beforePath: string;
  afterPath: string;
  changed: boolean;
}

function getChangedFiles(): string[] {
  try {
    const base = process.env.GITHUB_BASE_REF ?? "main";
    const output = execSync(`git diff --name-only origin/${base}...HEAD`, {
      encoding: "utf-8",
    });
    return output.trim().split("\n").filter(Boolean);
  } catch {
    return [];
  }
}

function ensureDir(dir: string): void {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

async function captureScreenshots(
  baseUrl: string,
  pages: PageConfig[],
  outputDir: string,
): Promise<Map<string, string>> {
  ensureDir(outputDir);
  const screenshots = new Map<string, string>();

  const requests = pages.flatMap((page) =>
    page.states.map((state) => ({
      url: page.path,
      viewport: page.viewport,
      waitForSelector: page.waitForSelector,
      actions: state.selector
        ? [
            {
              type: state.action ?? ("click" as const),
              selector: state.selector,
              waitAfter: state.waitAfter,
            },
          ]
        : undefined,
      _meta: { page: page.name, state: state.name },
    })),
  );

  console.log(`Capturing ${requests.length} screenshot(s) from ${baseUrl}...`);

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
  };
  if (API_KEY) {
    headers["X-API-Key"] = API_KEY;
  }

  const response = await fetch(`${WORKER_URL}/batch`, {
    method: "POST",
    headers,
    body: JSON.stringify({ baseUrl, pages: requests }),
  });

  if (!response.ok) {
    throw new Error(`Worker request failed: ${response.status}`);
  }

  const data = (await response.json()) as WorkerResponse;

  for (let i = 0; i < data.results.length; i++) {
    const result = data.results[i];
    const meta = requests[i]._meta;
    const filename = `${meta.page.toLowerCase().replace(/\s+/g, "-")}-${meta.state}.png`;
    const filepath = join(outputDir, filename);

    if (result.error) {
      console.warn(
        `  Error capturing ${meta.page} - ${meta.state}: ${result.error}`,
      );
      continue;
    }

    const imageBuffer = Buffer.from(result.image, "base64");
    writeFileSync(filepath, imageBuffer);
    screenshots.set(`${meta.page}-${meta.state}`, filepath);
    console.log(`  Captured ${meta.page} - ${meta.state}`);
  }

  return screenshots;
}

function compareImages(beforePath: string, afterPath: string): boolean {
  if (!existsSync(beforePath) || !existsSync(afterPath)) {
    return true;
  }

  const before = readFileSync(beforePath);
  const after = readFileSync(afterPath);

  return !before.equals(after);
}

function generateMarkdownReport(comparisons: ComparisonResult[]): string {
  const changed = comparisons.filter((c) => c.changed);
  const unchanged = comparisons.filter((c) => !c.changed);

  const lines: string[] = [
    "<!-- kumo-visual-regression -->",
    "## Visual Regression Report",
    "",
  ];

  if (changed.length === 0) {
    lines.push("No visual changes detected.");
    return lines.join("\n");
  }

  lines.push(`**${changed.length} page(s) with visual changes:**`);
  lines.push("");

  for (const comp of changed) {
    lines.push(`### ${comp.page} (${comp.state})`);
    lines.push("");
    lines.push("| Before | After |");
    lines.push("|--------|-------|");
    lines.push(
      `| ![Before](${comp.beforePath}) | ![After](${comp.afterPath}) |`,
    );
    lines.push("");
  }

  if (unchanged.length > 0) {
    lines.push("<details>");
    lines.push(`<summary>${unchanged.length} page(s) unchanged</summary>`);
    lines.push("");
    unchanged.forEach((c) => lines.push(`- ${c.page} (${c.state})`));
    lines.push("</details>");
  }

  lines.push("");
  lines.push("---");
  lines.push("*Generated by Kumo Visual Regression*");

  return lines.join("\n");
}

async function postPRComment(body: string): Promise<void> {
  const token = process.env.GITHUB_TOKEN;
  const prNumber = process.env.GITHUB_PR_NUMBER ?? process.env.PR_NUMBER;
  const repo = process.env.GITHUB_REPOSITORY ?? "cloudflare/kumo";

  if (!token || !prNumber) {
    console.log("Missing GITHUB_TOKEN or PR_NUMBER, skipping PR comment");
    console.log("\n--- Report ---\n");
    console.log(body);
    return;
  }

  const [owner, repoName] = repo.split("/");
  const marker = "<!-- kumo-visual-regression -->";

  const commentsResponse = await fetch(
    `https://api.github.com/repos/${owner}/${repoName}/issues/${prNumber}/comments`,
    {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json",
      },
    },
  );

  const comments = (await commentsResponse.json()) as Array<{
    id: number;
    body?: string;
  }>;
  const existingComment = comments.find((c) => c.body?.startsWith(marker));

  const url = existingComment
    ? `https://api.github.com/repos/${owner}/${repoName}/issues/comments/${existingComment.id}`
    : `https://api.github.com/repos/${owner}/${repoName}/issues/${prNumber}/comments`;

  const method = existingComment ? "PATCH" : "POST";

  await fetch(url, {
    method,
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github.v3+json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ body }),
  });

  console.log(`PR comment ${existingComment ? "updated" : "created"}`);
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const fullRegression = args.includes("--full");

  const beforeUrl = process.env.BEFORE_URL ?? "https://kumo-ui.com";
  const afterUrl =
    process.env.AFTER_URL ?? process.env.PREVIEW_URL ?? beforeUrl;

  let pages: PageConfig[];

  if (fullRegression) {
    pages = PAGE_CONFIGS;
    console.log("Running full visual regression...\n");
  } else {
    const changedFiles = getChangedFiles();
    pages = getAffectedPages(changedFiles);

    if (pages.length === 0) {
      console.log("No demo file changes detected. Skipping visual regression.");
      return;
    }

    console.log(`Found ${pages.length} affected page(s)\n`);
  }

  const beforeDir = join(SCREENSHOTS_DIR, "before");
  const afterDir = join(SCREENSHOTS_DIR, "after");

  console.log("=== Capturing BEFORE screenshots ===");
  const beforeScreenshots = await captureScreenshots(
    beforeUrl,
    pages,
    beforeDir,
  );

  console.log("\n=== Capturing AFTER screenshots ===");
  const afterScreenshots = await captureScreenshots(afterUrl, pages, afterDir);

  console.log("\n=== Comparing screenshots ===");
  const comparisons: ComparisonResult[] = [];

  for (const [key, beforePath] of beforeScreenshots) {
    const afterPath = afterScreenshots.get(key);
    if (!afterPath) continue;

    const [page, state] = key.split("-");
    const changed = compareImages(beforePath, afterPath);

    comparisons.push({
      page,
      state,
      beforePath,
      afterPath,
      changed,
    });

    console.log(`  ${page} (${state}): ${changed ? "CHANGED" : "unchanged"}`);
  }

  console.log("\n=== Generating report ===");
  const report = generateMarkdownReport(comparisons);
  await postPRComment(report);
}

main().catch((error) => {
  console.error("Visual regression failed:", error);
  process.exit(1);
});
